# リーダブルコード
## 訳者まえがき
>　**面白いと読みやすいは違う**

コーディングをすることにおいての読みやすさとは、**面白くする**という必要はない。
**いい名前を付ける**、**適切なコメントを記載する**、**意味のある単位ごとに分割し整形**することなどである。
そのような基本的なことを着実にするための説明を丁寧にこの本では記載している。

だが、あまりにも基本的なことばかり記載しているため、地味だと思われる方がいるかもしれないが、この本は面白い。

> **何がどう面白い**

なぜ面白いかというと、それはアドバイスの仕方がいいからだと思う。
他の本にありがちな説教じみた口調のものではなく、この本は先輩などの目上の方からの優しいアドバイスを受けているような口調である。
それに、200ページ弱にもかかわらず、説明用のサンプルも豊富で今日からすぐに使えるヒントも満載である。
よって、読み返そうと感じたときにすぐ取り出せ、誰かにコードを教えたことがあるひとはもれなく感動することだろう。

この本は「読みやすいコード」を書くことは「理解しやすいコード」を書くことであり、その結果「優れたコード」につながるということを信念としている。それも素晴らしいと感じる。
誰もが優れたコードを書きたいと思っているだろうが、その答えはこの本にすべて記載している。
これなら誰にも~~パクる~~マネする事ができるだろう。

## はじめに
> **本書について**

この本の目的は**読みやすいコードを書くこと**である。
具体的に言えば誰かが自分の書いたコードをよんで理解する時間を最短にすることである。
プログラマーが日常に時間を費やしていることはもっと「基本的」なことだと思う。
例を挙げると、変数に名前を付けたり、ループの処理を書いたりなどの大部分は既存のコードの読み書きに費やされている。
その作業がはかどるよう、日々のプログラミングのお役に立てることができれば幸いである。
良ければチームのメンバーにもこの本を推奨してほしい。

> **本書の読み方**

楽しく気軽に読んで欲しいため、1,2週間で読んで欲しい。
章ごとに独立しているためどこから読んでもらっても構わない。

## 第一章
> **「優れたコード」とは**

ひどいコードを長年集め、そのコードをどう改善すればいいのかを調べてみた。
すると、一つのテーマから生じていると分かった。
#### コードは理解しやすくしなければならない
ということだ。
プログラマーは何となく直感でプログラミングをしていることが多いため意識するべきだ。
例えば

```
for(Node* node=list->head; node !=NULL; node=node->next)
{

   Print(node->data);

}
```

は以下のコードよりも優れているとみんな思っている。
```
Node* node=list->head;
if(node==NULL) return;

while(node->next !=NULL){
   Print(node->data);
   node=node->next;
}
if(node !=NULL)Print(node->data);
```
どちらも動作は同じである。

でも、どちらが優れているかわからない場合もある。
それは簡潔にすることを重視するか、安心するコードを重視するかにかかっている。

> **読みやすさの基本**

先ほどのコードをたくさん調査した結果、すごく大切な基準になるものにたどり着いた。
#### コードは他の人が最短時間で理解できるように書かなければならない
この**理解する**ということばには高いハードルを設定している。
それは、変更を加えたり、バグを見つけたりできるという意味である。

> **小さなことは絶対にいいこと？**

```
assert((!(bucket=FindBucket)(key))||!bucket->IsOccupied());

```
この一行のコードと
```
bucket=FindBucket(key);
if(bucket !=NULL)assert(!bucket->IsOccupied());
```
この二行のコードなら、二行のほうが理解するまでの時間は短い。

それに理解する時間を早めるには、コメントを残すことも大切である。

> **理解するまでにかかる時間は競合する？**

率直に言うと競合しない。
高度に最適化されたコードであり、もっと理解しやすくできるはずだ。
常に一歩下がって**このコードは理解しやすいだろうか**と自問自答してみることが大切だ。

## 第二章
> **名前に情報を詰め込む**

名前を付けるときには、それが変数名であれ、関数名であれこうすればいい
#### 名前に情報を詰め込む
名前は短いコメントだと思えばいい。

> **明確なたんごを選ぶ**

「名前に明確な情報を詰め込む」には明確な単語を選ぶことが大切である。
例えば「get」というのはあまり明確な単語ではない。
どこからとってくるのかが明確ではない。
「get」という単語からは何が伝わってくるのか。
「step」も同様である。

> **tempやretval**などの汎用的な名前を避ける

これらの変数名は、「名前のことなんて考えていません」と言っているようなものなのでやめるべきだ。
#### 変数の値を表すようなな目を使おう

tmpに関しては、swapの際などの一時敵な保管に使用する場合は使用してもよい。

> **ループイテレーター**

ループ処理の際に使用するi,j,kは汎用的な名前だが、これだけで「ぼくはイテレーター」という意味になるので、問題ない。
#### このように汎用的な名前が役立つときもある

> **名前に情報を追加する**

例えば、
```
getTime();
```
という関数がある。
この関数はミリ秒を返す関数であるが、getTimeではなにを返すかわからない。
そのため、
```
getTime_ms();
```
のように_msを追加すれば明確になるだろう。

>　**名前の長さを決める**

いい名前を選ぶときには、「長い名前を避ける」という暗黙の制約がある。
長い変数名などは誰もが嫌がるだろう。

**スコープが小さければ短い名前でもよい**
その名前が見えるコードの
行数が小さければ多くの情報を詰め込む必要はない。
```
if(debug){
  map<string,int>m;
  LoolUpNamesNumbers(&m);
  Print(m);
}
```
mという変数名に情報が含まれていないが、コードを理解するのに必要な情報がすぐそばにあるため、大丈夫だ。

#### 長い名前を入力するのは問題じゃない
だが、名前の最初の文字を入力することなどを心掛けるべきだ。

> 名前のフォーマットで情報を伝える

アンダーバーやダッシュ、大文字を使って、名前に情報を詰め込むこともできる。
```
#define MACRO_NAME_
```
```
private:
  int offset_;
```
のように、大文字にアンダーバーの名前の場合は#defineであるとすぐに把握できるし、
privateでは、最後にアンダーバーを付けることで、publicと区別することができる。

> **本章のテーマ**

本章のテーマは、「名前に情報を詰め込む」だった。
つまり、名前を見ただけで情報をくみ取れるようにすることだ。
要約すると

- 明確な単語を選ぶ
- 汎用的な名前を避ける
- 具体的な名前を使って、物事を詳細に説明する
- 変数名に大切な情報を追加する
- スコープの大きな変数には長い名前を付ける
- 大文字やアンダーバーなどに意味を込める

ということだ。


> **ここまで読んで感じたこと**

訳者まえがきの時点で、**この本は面白く、かつ分かりやすい**と自信に満ち溢れているように感じた。
実際この本の筆者は訳者の角 征典さんではなくDustini Boswellさん,Trevor Foucherさんであるのに、
まえがきの時点でこの本のハードルを上げていることに驚いた。
それに、コードをわかりやすく書くことにおいて面白さは必要ないがこの本自体は面白いというギャグのようなものがほほえましいと感じた。
きっと、この本のファンであるのかまた、リスペクトが強いのだろうと感じた。

※今回訳者まえがきに記載されてある、島本和彦「アオイホノオ」やAmazon.comの下りなどは、**リーダブルコード**という本の説明として冗長と感じたため省略。

中の内容では、鍵となる考えや、説明用のコードがありわかりやすかった。
自分たちが書いているコードの書き方とは違うが、筆者が説明したいことはすべて伝わった。

それに、まえがきでも言っていたように脳に入りやすい口調であると感じた。
最後のまとめがすべてを語っていると感じた。





